const mongoose = require("mongoose");
const moment = require("moment");
const machines = require('../models/machines');
const blocks = require("../models/block");
const ops = require("../models/siteoption");
const users = require("../models/user");

const generateTimeBlocks = require("../helpers/generateTimeBlocks")
const milsPastMidnightToUnixTime = require("../helpers/milsAfterMidnightToUnixTime")

const resSchema = mongoose.Schema({
    machine: String,
    machineType: String,
    blocks: {type: [Number], required: true},
    date: {type: String, required: true}, // To figure out which set of blocks is being requested. The date is string as we are using a custom date
    start: {type: Number}, // These are genereated by the server
    end: {type: Number},
    status: Number, // Generated by the server
    user: {type: String, required: true}, // ID of the user
    description: {type: String, required: true} // The description is like the justfication
})

resSchema.pre('save', async function(next) {
  // Set the status
  // Note that more advanced statuses may be incorperated in the
  // future.
  this.status = 0
  // We also make sure that the date string is of the correct format
  let dateFormat = new RegExp(process.env.DATE_FORMAT); // Regex for date
  if (!dateFormat.test(this.get('date'))) {
    return next(new mongoose.Error.ValidationError("Invalid date format"));
  }
  if (!moment(this.date, "MM-DD-YYYY").isValid()) {
    return next(new Error("Invalid date format")) // This triggers a 400 error code
  }
  // We make sure that either a machine or a type were supplied
  if (!(this.machine || this.machineType)) {
      return next(new Error("Either a machine or a machine type should be supplied"));
  }
    // First, we make sure that the machine exists  (if a machine was supplied)
    if (this.machine) {
      let machine;
      try {
        machine = await machines.findById(this.machine)
      } catch (err) {
        if (err.name == "CastError") {
          return next(new Error("The machine is not a correct ID")); // The machine path is incorrect
        }
        console.log(err)
        return next(new Error(500)) // A server error occured
      }
      if (!machines) {
        return next(new Error("The supplied machine ID does not exist")); // The ID is not that of a machine
      }
    }
    if (this.machineType) {
        // Else, we find a machine for that type that is available
        // First, we find all machines for that type
        let matchingMachine = await machines.find({
          type: this.machineType
        });
        console.log("matchingMachine: ", matchingMachine);
        for (var i = 0; i < matchingMachine.length; i++) {
          let matchingBlocks = await blocks.find({
            machine: matchingMachine[i],
            date: this.date
          })
          if (matchingBlocks.length == 0) {
            // The blocks have not yet been generated for this machine at this time. It is available
            this.machine = matchingMachine[i]
            break;
          } else {
            // some of them may be unavailable
            let availableBolocks = matchingBlocks.find(x => x.available == true);
            if (availableBolocks.length == 0) {
              // This machine is not available at this time
            } else {
              // This machine is available
              this.machine = matchingMachine[i]
              break;
            }
          }
        }
    }
    let timeBlocks = await blocks.find()
    // We also make sure that the user exists
    let currentUser = await users.findOne({email: this.user}); // We don't have the ID yet
    if (!currentUser) {
        // If there is no user
        return next(new mongoose.Error.ValidationError);
    } else {
        this.user = currentUser._id;
    }
    // We also want to sort the array
    this.blocks.sort(function(a, b) {
        return a - b
    })
    // Then, we make sure that all blocks are sequential
    let previousBlock = this.blocks[0];
    for (var i = 1; i < this.blocks.length; i++) {
        let currentBlock = this.blocks[i];
        if (previousBlock != currentBlock - 1) {
          return next(new Error("Time blocks must be sequential"))
        }
        previousBlock = currentBlock;
    }
    // We want to generate the start and end times
    // let largestAndSmallest;
    // try {
    //     largestAndSmallest = await blocks.find({
    //         index: {
    //             $in: [this.blocks[0],this.blocks[this.blocks.length-1]]
    //         },
    //         machine: this.machine
    //     })
    // } catch(err) {
    //     next(new Error());
    // }
    // let startMilsAfterMidnight; 
    // let endMilsAfterMidnight; 
    // // Very important to make sure that if the user only wants one block everything
    // // does not crash.
    // if (largestAndSmallest.length != 1) {
    //     startMilsAfterMidnight = largestAndSmallest[0].startMilsPastMidnight;
    //     endMilsAfterMidnight = largestAndSmallest[1].endMilsPastMidnight;
    // } else {
    //     startMilsAfterMidnight = largestAndSmallest[0].startMilsPastMidnight;
    //     endMilsAfterMidnight = largestAndSmallest[0].endMilsAfterMidnight;
    // }
    // this.start = milsPastMidnightToUnixTime(startMilsAfterMidnight, this.date) // Converts the relative mils after midnight to a UNIX timestamp
    // this.end = milsPastMidnightToUnixTime(endMilsAfterMidnight, this.date)
    
    // Only then can we go forth with the reservation
    next();
});

const resModel = mongoose.model("reservation",resSchema);

module.exports = resModel;