const mongoose = require("mongoose");
const moment = require("moment");
const machines = require('../models/machines');
const ops = require("../models/siteoption");
const users = require("../models/user");

const milsPastMidnightToUnixTime = require("../helpers/milsAfterMidnightToUnixTime")
const indexToMilsAfterMidnight = require("../helpers/indexToMilsAfterMidnight");

const resSchema = mongoose.Schema({
    machine: String,
    machineType: String,
    blocks: {type: [Number], required: true},
    date: {type: String, required: true}, // To figure out which set of blocks is being requested. The date is string as we are using a custom date
    start: {type: Number}, // These are genereated by the server
    end: {type: Number},
    start_expires: Number,
    end_expires: Number,
    cancel_expires: Number,
    status: Number, // Generated by the server
    user: {type: String, required: true}, // ID of the user
    description: {type: String, required: true} // The description is like the justfication
})
/**
 * Strike system:
 * Every time the server sees that the user
 * has not shown up and started their
 * reservation, it will give them a strike. It
 * will give them another strike if they don't cancel
 * their reservation on time (to say that they have
 * left). The following is a list of all events that
 * cause a strike:
 * a) Starting a reservation too late
 * b) Ending a reservation too late
 * c) Cancelling a reservation too late
 * The exact amount of strikes given depends on the event
 * a) Starting ending, and cancelling a reservation too late depends on the
 * amount of blocks they have taken. let a = the amount of blocks and
 * b = a constant, the strikes given is ab.
 * 
 * There is a limited amount of strikes an account may have. If
 * they reach that amount, their account enters ACCOUNT SUSPENSION
 * until their limit is increased. The amount of strikes a student 
 * has does not go away –– the teacher mearly changes the max amount of
 * strikes they can have.
 */
/** 
 * The the start_expires value is when
 * the window to start the reservation closes. The
 * end_expires is when they rub out of time to mark a reservation as ended.
 * The cancel_expires is when the allowable window to cancel
 * a reservation closes, and the student will loose points for
 * cancelling their reservation. The rules for these values are as below
 * start_expires > start
 * end_expires > end
 * cancel_expires < start
 * It is used by the client to show a countdown
 * until their spot is yield to another person. The
 * server periodically checks to see if the start times
 * for the next few reservations exceeds the current time 
 * and, if so, it will award the appropriate amount of strikes.
*/
/**
 * Status codes
 * ### Admin Codes
 * -2: Cancelled by admin
 * -1: On hold
 * ### Regular Codes ###
 * > 0: Approved and preparing to take place
 * > 1: Started –– Confirmed by user
 * > 2: Ended –– Confirmed by user
 * > 3: Prolonged by user
 * ### Cancellation Codes ###
 * > 4: Cancelled –– On time
 * > 5: Cancelled –– Too late
 * ### Bad user behaviour
 * > 6: Started –– No user confirmation
 * A reservation will wait for 10 minutes before timing out and concluding that 
 * the user has not shown up. The next user will then be informed that
 * their reservation will be taking place earlier. Thus, the time shown on
 * the start and end times will not necessarilt conform with
 * the time blocks –– they are only there for administrative
 * purposes
 * > 7: Prolonged –– No user confirmation
 * If a user does not mark their reservation as ended, it will wait for
 * 10 minutues before ending it for them. 
 */

resSchema.pre('save', async function(next) {
  // Set the status
  // Note that more advanced statuses may be incorperated in the
  // future.
  this.status = 0
  // We also make sure that the date string is of the correct format
  let dateFormat = new RegExp(process.env.DATE_FORMAT); // Regex for date
  if (!dateFormat.test(this.get('date'))) {
    return next(new mongoose.Error.ValidationError("Invalid date format"));
  }
  if (!moment(this.date, "MM-DD-YYYY").isValid()) {
    return next(new Error("Invalid date format")) // This triggers a 400 error code
  }
  // We make sure that either a machine or a type were supplied
  if (!(this.machine || this.machineType)) {
      return next(new Error("Either a machine or a machine type should be supplied"));
  }
    // First, we make sure that the machine exists  (if a machine was supplied)
    if (this.machine) {
      let machine;
      try {
        machine = await machines.findById(this.machine)
      } catch (err) {
        if (err.name == "CastError") {
          return next(new Error("The machine is not a correct ID")); // The machine path is incorrect
        }
        console.log(err)
        return next(new Error(500)) // A server error occured
      }
      if (!machines) {
        return next(new Error("The supplied machine ID does not exist")); // The ID is not that of a machine
      }
    }
    // We also make sure that the user exists
    if (!(await users.findById(this.user))) {
        // If there is no user for that ID
        return next(new mongoose.Error.ValidationError);
    }
    // We also want to sort the array
    this.blocks.sort(function(a, b) {
        return a - b
    })
    // Then, we make sure that all blocks are sequential
    let previousBlock = this.blocks[0];
    for (var i = 1; i < this.blocks.length; i++) {
        let currentBlock = this.blocks[i];
        if (previousBlock != currentBlock - 1) {
          return next(new Error("Time blocks must be sequential"))
        }
        previousBlock = currentBlock;
    }
    // Then we generate the start and end times
    /**
     * The indexToMilsAfterMidnight function is asynchronous. Thus, we must wait for its completion before
     * we can do anything. Not putting await will result in start and end being NaN. 
     */
    let start = milsPastMidnightToUnixTime(await indexToMilsAfterMidnight(this.blocks[0]), this.date);
    /**
     * The end time block's index must be incremented by one. This is a nifty little trick that takes advantage of
     * the fact that the end of one block is the beginning of the next.
     */
    let end = milsPastMidnightToUnixTime(await indexToMilsAfterMidnight(this.blocks[this.blocks.length - 1] + 1), this.date);
    this.set("start",start);
    this.set("end", end);
    // We also want to generate the start_expires, end_expires, and cancel_expires
    // Get the options
    let resExpire = (await ops.findOne({key: 6})).get("valueNumber");
    let cancelExpire = (await ops.findOne({key: 7})).get("valueNumber");
    // Set the values
    this.set("start_expires", this.get("start") + resExpire);
    this.set("end_expires", this.get("end") + resExpire);
    this.set("cancel_expires", this.get("start") - cancelExpire);
    // Then we proceed
    next();
});

const resModel = mongoose.model("reservation",resSchema);

module.exports = resModel;